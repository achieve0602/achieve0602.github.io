<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js 500k ç²’å­æ¥µé™ç‰ˆ (å¤šæ¨¡æ…‹æ§åˆ¶)</title>
    <!-- å¼•å…¥ Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <!-- å¼•å…¥ Post-processing -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>

    <!-- å¼•å…¥ MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            user-select: none; /* é˜²æ­¢æ‹–æ‹½é¸ä¸­æ–‡å­— */
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            cursor: grab; /* é¼ æ¨™æ‰‹å‹ */
        }
        
        #canvas-container:active {
            cursor: grabbing;
        }

        #input_video {
            position: absolute;
            top: 0;
            left: 0;
            opacity: 0; 
            pointer-events: none;
            z-index: 0;
        }

        #overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.9);
            z-index: 10;
            background: rgba(10, 10, 10, 0.7);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(15px);
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
            min-width: 220px;
            transition: all 0.3s ease;
        }

        h1 {
            font-size: 18px;
            margin: 0 0 15px 0;
            color: #ffaa00;
            text-transform: uppercase;
            letter-spacing: 2px;
            border-bottom: 1px solid rgba(255,255,255,0.15);
            padding-bottom: 10px;
            text-shadow: 0 0 15px rgba(255, 170, 0, 0.5);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .status-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            font-size: 14px;
        }

        .status-label { opacity: 0.7; }
        .status-value { font-weight: bold; color: #fff; }

        #hand-status { color: #888; transition: color 0.3s; }

        .control-group {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(255,255,255,0.1);
        }

        .btn-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        button {
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            color: white;
            padding: 4px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: 0.2s;
        }

        button:hover { background: rgba(255,255,255,0.2); }
        button:active { transform: scale(0.95); }
        
        button.active {
            background: rgba(255, 170, 0, 0.3);
            border-color: rgba(255, 170, 0, 0.6);
            color: #ffaa00;
            text-shadow: 0 0 5px rgba(255, 170, 0, 0.5);
        }

        .sensitivity-val { font-family: monospace; color: #00ffff; }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ffaa00;
            font-size: 24px;
            z-index: 20;
            background: rgba(0,0,0,0.9);
            padding: 40px 60px;
            border-radius: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            border: 1px solid rgba(255, 170, 0, 0.3);
            box-shadow: 0 0 50px rgba(255, 170, 0, 0.1);
            text-align: center;
            pointer-events: none;
        }

        .loader {
            border: 3px solid rgba(255,255,255,0.1);
            border-left-color: #ffaa00;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        .instruction { margin-top: 8px; font-size: 12px; color: #888; }
        .key-instruction span { color: #ddd; font-weight: bold; }
        
        .mouse-instruction {
            margin-top: 5px;
            padding-top: 5px;
            border-top: 1px dashed rgba(255,255,255,0.1);
        }
    </style>
</head>
<body>

    <div id="loading">
        <div class="loader"></div>
        <div>ULTRA å¼•æ“åˆå§‹åŒ–ä¸­...</div>
        <div style="font-size:14px; margin-top:10px; color:#666;">æ”¯æŒ æ‰‹å‹¢ & é¼ æ¨™ é›™é‡æ§åˆ¶<br>æ­£åœ¨ç”Ÿæˆ 500,000 å€‹ç²’å­</div>
    </div>

    <div id="overlay">
        <h1>Galaxy Engine <span style="font-size:10px; color:#00ffff; border:1px solid #00ffff; padding:2px 4px; border-radius:3px; text-shadow:none;">ULTRA</span></h1>
        
        <div class="status-item">
            <span class="status-label">é€£æ¥ç‹€æ…‹</span>
            <span id="hand-status" class="status-value">â— é¼ æ¨™å¾…æ©Ÿ</span>
        </div>
        <div class="status-item">
            <span class="status-label">ç¸®æ”¾å€ç‡</span>
            <span id="zoom-value" class="status-value" style="color:#00ffff">1.0x</span>
        </div>
        <div class="status-item">
            <span class="status-label">ç²’å­ç¸½æ•¸</span>
            <span class="status-value" style="font-family:monospace">500k+</span>
        </div>

        <div class="control-group">
            <div class="btn-row">
                <span class="status-label">éˆæ•åº¦</span>
                <div>
                    <button onclick="adjustSensitivity(-0.5)">-</button>
                    <span id="sens-val" class="sensitivity-val">3.0</span>
                    <button onclick="adjustSensitivity(0.5)">+</button>
                </div>
            </div>
            <div class="btn-row" style="margin-top:15px;">
                <button id="rtx-btn" onclick="toggleRayTracing()" style="width:100%; padding:8px;">
                    âœ¨ é–‹å•Ÿå…‰ç·šè¿½è¹¤ (æ¨¡æ“¬)
                </button>
            </div>
        </div>
        
        <hr style="border: 0; border-top: 1px solid rgba(255,255,255,0.1); margin: 15px 0;">
        <div class="instruction key-instruction">âœ‹ <span>æ‰‹æŒä½ç§»</span> / æ—‹è½‰è¦–è§’</div>
        <div class="instruction key-instruction">ğŸ‘‹ <span>æ‰‹æŒå‚¾æ–œ</span> / ç¿»è½‰æ˜Ÿé«”</div>
        <div class="instruction key-instruction">ğŸ‘Œ <span>æŒ‡å°–æåˆ</span> / ç¸®æ”¾æ§åˆ¶</div>
        
        <div class="instruction key-instruction mouse-instruction">ğŸ–±ï¸ <span>é¼ æ¨™ç§»å‹•</span> / æ—‹è½‰è¦–è§’</div>
        <div class="instruction key-instruction">ğŸ–±ï¸ <span>æ»¾è¼ªæ»¾å‹•</span> / ç¸®æ”¾æ§åˆ¶</div>
        <div class="instruction key-instruction">ğŸ–±ï¸ <span>å·¦éµæ‹–æ‹½</span> / Zè»¸ç¿»è½‰</div>
    </div>

    <video id="input_video"></video>
    <div id="canvas-container"></div>

<script>
    // ==========================================
    // é…ç½®åƒæ•¸
    // ==========================================
    const config = {
        particleCount: 500000, 
        planetColor: new THREE.Color(0xffaa00),
        ringColor: new THREE.Color(0x88ccff),
    };

    let handDetected = false;
    let rotationSensitivity = 3.0; 
    
    // äº¤äº’ç›®æ¨™å€¼
    let targetRotationX = 0.3;
    let targetRotationY = 0;
    let targetRotationZ = 0.2;
    let currentScale = 1.0;
    let targetScale = 1.0;
    let lastInteractionTime = 0; // ç”¨æ–¼åˆ¤æ–·æ˜¯å¦é–’ç½®

    // å…‰è¿½ç‹€æ…‹
    let isRayTracing = false;
    
    // ==========================================
    // Three.js åˆå§‹åŒ–
    // ==========================================
    const container = document.getElementById('canvas-container');
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000000, 0.0008); 

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
    camera.position.z = 40; 

    const renderer = new THREE.WebGLRenderer({ antialias: false, alpha: false, powerPreference: "high-performance" });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(1);
    renderer.toneMapping = THREE.ACESFilmicToneMapping; 
    renderer.toneMappingExposure = 1.0;
    container.appendChild(renderer.domElement);

    // --- Post-processing (Bloom) ---
    const renderScene = new THREE.RenderPass(scene, camera);
    const bloomPass = new THREE.UnrealBloomPass(
        new THREE.Vector2(window.innerWidth, window.innerHeight),
        1.5, 0.5, 0.1  
    );

    const composer = new THREE.EffectComposer(renderer);
    composer.addPass(renderScene);
    composer.addPass(bloomPass);

    // --- é«˜æ¸…ç´‹ç† ---
    function getTexture() {
        const canvas = document.createElement('canvas');
        canvas.width = 32;
        canvas.height = 32;
        const ctx = canvas.getContext('2d');
        const gradient = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
        gradient.addColorStop(0, 'rgba(255,255,255,1)');
        gradient.addColorStop(0.2, 'rgba(255,255,255,0.8)');
        gradient.addColorStop(0.5, 'rgba(255,255,255,0.1)');
        gradient.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 32, 32);
        return new THREE.CanvasTexture(canvas);
    }
    const commonTexture = getTexture();

    // ==========================================
    // 1. åœŸæ˜Ÿç²’å­ç³»çµ±
    // ==========================================
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(config.particleCount * 3);
    const colors = new Float32Array(config.particleCount * 3);
    
    const planetRadius = 8;
    const ringInnerRadius = 10;
    const ringOuterRadius = 22;
    const planetParticleRatio = 0.45;

    const colPlanet = config.planetColor;
    const colRing = config.ringColor;

    for (let i = 0; i < config.particleCount; i++) {
        let x, y, z, r, g, b;
        
        if (i < config.particleCount * planetParticleRatio) {
            const dist = Math.pow(Math.random(), 0.5) * planetRadius; 
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            x = dist * Math.sin(phi) * Math.cos(theta);
            y = dist * Math.sin(phi) * Math.sin(theta);
            z = dist * Math.cos(phi);
            r = colPlanet.r + (Math.random() - 0.5) * 0.1;
            g = colPlanet.g + (Math.random() - 0.5) * 0.1;
            b = colPlanet.b + (Math.random() - 0.5) * 0.1;
        } else {
            const randVal = Math.random();
            const ringRad = Math.sqrt(randVal * (ringOuterRadius**2 - ringInnerRadius**2) + ringInnerRadius**2);
            const theta = Math.random() * Math.PI * 2;
            x = ringRad * Math.cos(theta);
            z = ringRad * Math.sin(theta);
            const thickness = 0.3 * (1 - (ringRad - ringInnerRadius)/(ringOuterRadius - ringInnerRadius));
            const wave = Math.sin(theta * 10) * 0.1;
            y = (Math.random() - 0.5) * thickness + wave * 0.2;
            const t = (ringRad - ringInnerRadius) / (ringOuterRadius - ringInnerRadius);
            r = colRing.r * (1-t) + t;
            g = colRing.g * (1-t) + t;
            b = colRing.b * (1-t) + t;
        }
        positions[i * 3] = x;
        positions[i * 3 + 1] = y;
        positions[i * 3 + 2] = z;
        colors[i * 3] = r;
        colors[i * 3 + 1] = g;
        colors[i * 3 + 2] = b;
    }

    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

    const material = new THREE.PointsMaterial({
        size: 0.12,
        map: commonTexture,
        vertexColors: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        transparent: true,
        opacity: 0.6 
    });

    const planetSystem = new THREE.Points(geometry, material);
    scene.add(planetSystem);

    // ==========================================
    // 2. å¤šå±¤æ¬¡èƒŒæ™¯æ˜Ÿç©º
    // ==========================================
    const bgGroup = new THREE.Group();
    scene.add(bgGroup);

    // é æ™¯å¾®å¡µ
    const dustCount = 30000;
    const dustGeo = new THREE.BufferGeometry();
    const dustPos = new Float32Array(dustCount * 3);
    for(let i=0; i<dustCount*3; i++) {
        const r = 400 + Math.random() * 400;
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        dustPos[i] = r * Math.sin(phi) * Math.cos(theta);
        dustPos[i+1] = r * Math.sin(phi) * Math.sin(theta);
        dustPos[i+2] = r * Math.cos(phi);
    }
    dustGeo.setAttribute('position', new THREE.BufferAttribute(dustPos, 3));
    const dustMat = new THREE.PointsMaterial({
        color: 0x444466, size: 0.8, transparent: true, opacity: 0.4, sizeAttenuation: false
    });
    bgGroup.add(new THREE.Points(dustGeo, dustMat));

    // ä¸­æ™¯æ†æ˜Ÿ
    const starCount = 5000;
    const starGeo = new THREE.BufferGeometry();
    const starPos = new Float32Array(starCount * 3);
    const starCol = new Float32Array(starCount * 3);
    for(let i=0; i<starCount; i++) {
        const r = 200 + Math.random() * 300;
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        starPos[i*3] = r * Math.sin(phi) * Math.cos(theta);
        starPos[i*3+1] = r * Math.sin(phi) * Math.sin(theta);
        starPos[i*3+2] = r * Math.cos(phi);
        const colorType = Math.random();
        let c = new THREE.Color();
        if(colorType > 0.8) c.setHex(0xffddaa); 
        else if(colorType > 0.6) c.setHex(0xaaddff);
        else c.setHex(0xffffff);
        starCol[i*3] = c.r; starCol[i*3+1] = c.g; starCol[i*3+2] = c.b;
    }
    starGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
    starGeo.setAttribute('color', new THREE.BufferAttribute(starCol, 3));
    const starMat = new THREE.PointsMaterial({
        size: 1.5, map: commonTexture, vertexColors: true, transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending
    });
    bgGroup.add(new THREE.Points(starGeo, starMat));

    // ==========================================
    // é¼ æ¨™æ§åˆ¶é‚è¼¯
    // ==========================================
    let isMouseDown = false;
    let mouseX = 0;
    let clickX = 0;

    window.addEventListener('mousemove', (e) => {
        // å¦‚æœæ‰‹å‹¢æ­£åœ¨æ§åˆ¶ï¼Œå¿½ç•¥é¼ æ¨™
        if (handDetected) return;
        
        // æ›´æ–°äº¤äº’æ™‚é–“
        lastInteractionTime = clock.getElapsedTime();

        const x = e.clientX / window.innerWidth;
        const y = e.clientY / window.innerHeight;

        // XY è»¸æ—‹è½‰ (æ˜ å°„å±å¹•ä½ç½®åˆ°è§’åº¦)
        targetRotationY = (x - 0.5) * Math.PI * rotationSensitivity;
        targetRotationX = (y - 0.5) * Math.PI * rotationSensitivity;

        // å¦‚æœæŒ‰ä½å·¦éµï¼Œè¨ˆç®— Z è»¸ç¿»è½‰
        if (isMouseDown) {
            const deltaX = (e.clientX - clickX) / window.innerWidth;
            targetRotationZ += deltaX * 0.1;
        }
    });

    window.addEventListener('mousedown', (e) => {
        if (handDetected) return;
        isMouseDown = true;
        clickX = e.clientX;
        lastInteractionTime = clock.getElapsedTime();
    });

    window.addEventListener('mouseup', () => {
        isMouseDown = false;
    });

    window.addEventListener('wheel', (e) => {
        if (handDetected) return;
        lastInteractionTime = clock.getElapsedTime();
        
        // æ»¾è¼ªç¸®æ”¾
        const zoomSpeed = 0.002;
        targetScale -= e.deltaY * zoomSpeed;
        
        // é™åˆ¶ç¸®æ”¾
        if(targetScale < 1.0) targetScale = 1.0;
        if(targetScale > 5.0) targetScale = 5.0;

        updateZoomUI(targetScale);
    });

    // ==========================================
    // UI æ§åˆ¶å‡½æ•¸
    // ==========================================
    function adjustSensitivity(val) {
        rotationSensitivity += val;
        if(rotationSensitivity < 0.5) rotationSensitivity = 0.5;
        if(rotationSensitivity > 10.0) rotationSensitivity = 10.0;
        document.getElementById('sens-val').innerText = rotationSensitivity.toFixed(1);
    }

    function toggleRayTracing() {
        isRayTracing = !isRayTracing;
        const btn = document.getElementById('rtx-btn');
        if (isRayTracing) {
            btn.classList.add('active');
            btn.innerText = "âœ¨ å…‰ç·šè¿½è¹¤å·²é–‹å•Ÿ (High-DPI)";
            renderer.setPixelRatio(window.devicePixelRatio); 
            bloomPass.strength = 2.0; 
            bloomPass.radius = 0.8;
            renderer.toneMappingExposure = 1.3;
            composer.setSize(window.innerWidth * window.devicePixelRatio, window.innerHeight * window.devicePixelRatio);
        } else {
            btn.classList.remove('active');
            btn.innerText = "âœ¨ é–‹å•Ÿå…‰ç·šè¿½è¹¤ (æ¨¡æ“¬)";
            renderer.setPixelRatio(1);
            bloomPass.strength = 1.5;
            bloomPass.radius = 0.5;
            renderer.toneMappingExposure = 1.0;
            composer.setSize(window.innerWidth, window.innerHeight);
        }
    }

    function updateZoomUI(scale) {
        const zoomEl = document.getElementById('zoom-value');
        zoomEl.innerText = scale.toFixed(1) + "x";
        const t = (scale - 1.0) / 4.0;
        const hue = 180 + t * 180;
        zoomEl.style.color = `hsl(${hue}, 100%, 70%)`;
    }

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        const pixelRatio = isRayTracing ? window.devicePixelRatio : 1;
        composer.setSize(window.innerWidth * pixelRatio, window.innerHeight * pixelRatio);
    });

    // ==========================================
    // æ¸²æŸ“å¾ªç’°
    // ==========================================
    const clock = new THREE.Clock();

    function animate() {
        requestAnimationFrame(animate);
        const time = clock.getElapsedTime();

        // 1. å¹³æ»‘æ’å€¼
        planetSystem.rotation.x = THREE.MathUtils.lerp(planetSystem.rotation.x, targetRotationX, 0.08);
        planetSystem.rotation.y = THREE.MathUtils.lerp(planetSystem.rotation.y, targetRotationY, 0.08);
        planetSystem.rotation.z = THREE.MathUtils.lerp(planetSystem.rotation.z, targetRotationZ, 0.08);
        currentScale = THREE.MathUtils.lerp(currentScale, targetScale, 0.1);
        planetSystem.scale.set(currentScale, currentScale, currentScale);

        // 2. å¾…æ©Ÿè‡ªå‹•å¾©ä½é‚è¼¯
        // å¦‚æœæ²’æœ‰æ‰‹å‹¢ï¼Œä¸”é¼ æ¨™åœæ­¢æ“ä½œè¶…é 2 ç§’
        const timeSinceInteraction = time - lastInteractionTime;
        const isIdle = !handDetected && timeSinceInteraction > 2.0;

        if (isIdle) {
            targetRotationY += 0.0005; // è‡ªå‹•æ—‹è½‰
            bgGroup.rotation.y -= 0.0001;
            targetScale = 1.0; // è‡ªå‹•å¾©ä½ç¸®æ”¾
            updateZoomUI(currentScale); // å¹³æ»‘æ›´æ–°UIé¡¯ç¤º
        }

        // 3. è¼å…‰å‘¼å¸
        bloomPass.strength = (isRayTracing ? 2.0 : 1.5) + Math.sin(time * 0.5) * 0.1;

        composer.render();
    }
    animate();

    // ==========================================
    // MediaPipe é‚è¼¯
    // ==========================================
    const videoElement = document.getElementById('input_video');
    const handStatus = document.getElementById('hand-status');
    const loadingScreen = document.getElementById('loading');

    function onResults(results) {
        if (loadingScreen.style.display !== 'none') loadingScreen.style.display = 'none';

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            if (!handDetected) {
                handDetected = true;
                lastInteractionTime = clock.getElapsedTime();
                handStatus.innerText = "â— å·²é€£æ¥ (æ‰‹å‹¢)";
                handStatus.style.color = "#00ff00";
                handStatus.style.textShadow = "0 0 10px #00ff00";
            }
            processHandInteraction(results.multiHandLandmarks[0]);
        } else {
            if (handDetected) {
                handDetected = false;
                handStatus.innerText = "â— é¼ æ¨™å¾…æ©Ÿ";
                handStatus.style.color = "#888";
                handStatus.style.textShadow = "none";
            }
        }
    }

    function processHandInteraction(landmarks) {
        lastInteractionTime = clock.getElapsedTime(); // ä¿æŒæ´»èº

        const wrist = landmarks[0];
        const middleMCP = landmarks[9];
        
        // æ—‹è½‰æ§åˆ¶
        const handX = middleMCP.x;
        const handY = middleMCP.y;
        targetRotationY = (handX - 0.5) * Math.PI * rotationSensitivity;
        targetRotationX = (handY - 0.5) * Math.PI * rotationSensitivity;

        // Zè»¸ç¿»è½‰
        const dx = middleMCP.x - wrist.x;
        const dy = middleMCP.y - wrist.y;
        targetRotationZ = Math.atan2(dx, -dy);

        // ç¸®æ”¾æ§åˆ¶
        const thumbTip = landmarks[4];
        const indexTip = landmarks[8];
        const pinchDist = Math.hypot(thumbTip.x - indexTip.x, thumbTip.y - indexTip.y);
        
        let scale = 1.0 + (pinchDist - 0.05) * 8.0; 
        if (scale < 1.0) scale = 1.0;
        if (scale > 5.0) scale = 5.0;
        targetScale = scale;
        
        updateZoomUI(targetScale);
    }

    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5});
    hands.onResults(onResults);

    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => await hands.send({image: videoElement}),
        width: 640, height: 480
    });
    cameraUtils.start();

</script>
</body>
</html>
