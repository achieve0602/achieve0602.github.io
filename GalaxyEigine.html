<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Galaxy</title>
    <!-- å¼•å…¥ Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <!-- å¼•å…¥ Post-processing -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>

    <!-- å¼•å…¥ MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            cursor: grab;
        }
        
        #canvas-container:active { cursor: grabbing; }

        #input_video {
            position: absolute;
            top: 0;
            left: 0;
            opacity: 0; 
            pointer-events: none;
            z-index: 0;
        }

        /* è¨­ç½®æŒ‰éˆ• (å·¦ä¸Šè§’) */
        #toggle-btn {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 20;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: #fff;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            font-size: 20px;
            cursor: pointer;
            backdrop-filter: blur(5px);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        #toggle-btn:hover {
            background: rgba(255, 170, 0, 0.3);
            border-color: #ffaa00;
        }

        #overlay {
            position: absolute;
            top: 70px;
            left: 20px;
            color: rgba(255, 255, 255, 0.9);
            z-index: 10;
            background: rgba(10, 10, 10, 0.8);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(15px);
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
            min-width: 240px;
            transition: opacity 0.3s ease, transform 0.3s ease;
            opacity: 1;
            transform: translateY(0);
        }

        #overlay.hidden {
            opacity: 0;
            transform: translateY(-20px);
            pointer-events: none;
        }

        h1 {
            font-size: 18px;
            margin: 0 0 15px 0;
            color: #ffaa00;
            text-transform: uppercase;
            letter-spacing: 2px;
            border-bottom: 1px solid rgba(255,255,255,0.15);
            padding-bottom: 10px;
            text-shadow: 0 0 15px rgba(255, 170, 0, 0.5);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .status-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            font-size: 14px;
        }

        .status-label { opacity: 0.7; }
        .status-value { font-weight: bold; color: #fff; }

        #hand-status { color: #888; transition: color 0.3s; }

        .control-group {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(255,255,255,0.1);
        }

        .btn-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        button.ctrl-btn {
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            color: white;
            padding: 4px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: 0.2s;
        }

        button.ctrl-btn:hover { background: rgba(255,255,255,0.2); }
        button.ctrl-btn.active {
            background: rgba(255, 170, 0, 0.3);
            border-color: rgba(255, 170, 0, 0.6);
            color: #ffaa00;
            text-shadow: 0 0 5px rgba(255, 170, 0, 0.5);
        }

        .sensitivity-val { font-family: monospace; color: #00ffff; }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ffaa00;
            font-size: 24px;
            z-index: 20;
            background: rgba(0,0,0,0.9);
            padding: 40px 60px;
            border-radius: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            border: 1px solid rgba(255, 170, 0, 0.3);
            box-shadow: 0 0 50px rgba(255, 170, 0, 0.1);
            text-align: center;
            pointer-events: none;
            width: 80%;
            max-width: 400px;
        }

        .loader {
            border: 3px solid rgba(255,255,255,0.1);
            border-left-color: #ffaa00;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        .instruction { margin-top: 8px; font-size: 12px; color: #888; }
        .key-instruction span { color: #ddd; font-weight: bold; }
        .mouse-instruction { margin-top: 5px; padding-top: 5px; border-top: 1px dashed rgba(255,255,255,0.1); }
        
        .mobile-hidden { display: block; }
        .desktop-hidden { display: none; }
    </style>
</head>
<body>

    <button id="toggle-btn" onclick="toggleOverlay()">âš™ï¸</button>

    <div id="loading">
        <div class="loader"></div>
        <div>SOLAR å¼•æ“åˆå§‹åŒ–ä¸­...</div>
        <div style="font-size:14px; margin-top:10px; color:#666;">
            æª¢æ¸¬è¨­å‚™: <span id="device-type" style="color:#fff">...</span><br>
            æ­£åœ¨ç”Ÿæˆ 500,000 å€‹ç²’å­
        </div>
    </div>

    <div id="overlay">
        <h1>Galaxy Engine <span style="font-size:10px; color:#ffaa00; border:1px solid #ffaa00; padding:2px 4px; border-radius:3px; text-shadow:none;">SOLAR</span></h1>
        
        <div class="status-item">
            <span class="status-label">é€£æ¥ç‹€æ…‹</span>
            <span id="hand-status" class="status-value">â— å¾…æ©Ÿ</span>
        </div>
        <div class="status-item">
            <span class="status-label">ç¸®æ”¾å€ç‡</span>
            <span id="zoom-value" class="status-value" style="color:#00ffff">1.0x</span>
        </div>
        <div class="status-item">
            <span class="status-label">ç²’å­ç¸½æ•¸</span>
            <span class="status-value" style="font-family:monospace">500k</span>
        </div>

        <div class="control-group">
            <div class="btn-row">
                <span class="status-label">éˆæ•åº¦</span>
                <div>
                    <button class="ctrl-btn" onclick="adjustSensitivity(-0.5)">-</button>
                    <span id="sens-val" class="sensitivity-val">3.0</span>
                    <button class="ctrl-btn" onclick="adjustSensitivity(0.5)">+</button>
                </div>
            </div>
            <div class="btn-row" style="margin-top:15px;">
                <button class="ctrl-btn" id="rtx-btn" onclick="toggleRayTracing()" style="width:100%; padding:8px;">
                    âœ¨ é–‹å•Ÿå…‰ç·šè¿½è¹¤ (æ¨¡æ“¬)
                </button>
            </div>
        </div>
        
        <hr style="border: 0; border-top: 1px solid rgba(255,255,255,0.1); margin: 15px 0;">
        <div class="instruction key-instruction">âœ‹ <span>æ‰‹æŒ/å–®æŒ‡</span> æ§åˆ¶è¦–è§’æ—‹è½‰</div>
        <div class="instruction key-instruction">ğŸ‘Œ <span>æåˆ/é›™æŒ‡</span> æ§åˆ¶ç¸®æ”¾å¤§å°</div>
        <div class="instruction key-instruction mobile-hidden">ğŸ‘‹ <span>å‚¾æ–œ/æ‹–æ‹½</span> æ§åˆ¶æ˜Ÿé«”ç¿»è½‰</div>
        
        <div class="instruction key-instruction mouse-instruction mobile-hidden">ğŸ–±ï¸ <span>é¼ æ¨™/è§¸å±</span> å…¨æ¨¡å¼æ”¯æŒ</div>
    </div>

    <video id="input_video"></video>
    <div id="canvas-container"></div>

<script>
    // ==========================================
    // è¨­å‚™æª¢æ¸¬èˆ‡åˆå§‹åŒ–
    // ==========================================
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    
    // åˆå§‹åŒ–è®Šé‡
    let rotationSensitivity = isMobile ? 2.0 : 3.0; // æ‰‹æ©Ÿé»˜èª 2.0
    const idleText = isMobile ? "â— è§¸å±å¾…æ©Ÿ" : "â— é¼ æ¨™å¾…æ©Ÿ";

    // æ›´æ–° DOM
    document.getElementById('device-type').innerText = isMobile ? "ç§»å‹•ç«¯ (Mobile)" : "æ¡Œé¢ç«¯ (Desktop)";
    document.getElementById('sens-val').innerText = rotationSensitivity.toFixed(1);
    document.getElementById('hand-status').innerText = idleText;

    // æ‰‹æ©Ÿç«¯éš±è—é¢æ¿èˆ‡éƒ¨åˆ†æç¤º
    if (isMobile) {
        document.getElementById('overlay').classList.add('hidden');
        document.querySelectorAll('.mobile-hidden').forEach(el => el.style.display = 'block'); 
        document.querySelectorAll('.mouse-instruction').forEach(el => el.style.display = 'none');
    }

    // ==========================================
    // é…ç½®åƒæ•¸
    // ==========================================
    const config = {
        particleCount: 500000, 
        planetColor: new THREE.Color(0xffaa00),
        ringColor: new THREE.Color(0x88ccff)
    };

    let handDetected = false;
    
    // äº¤äº’ç›®æ¨™å€¼
    let targetRotationX = 0.3;
    let targetRotationY = 0;
    let targetRotationZ = 0.2;
    let currentScale = 1.0;
    let targetScale = 1.0;
    let lastInteractionTime = 0;

    // å…‰è¿½ç‹€æ…‹
    let isRayTracing = false;
    
    // ==========================================
    // Three.js åˆå§‹åŒ–
    // ==========================================
    const container = document.getElementById('canvas-container');
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000000, 0.0005); 

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
    camera.position.z = 40; 

    const renderer = new THREE.WebGLRenderer({ antialias: false, alpha: false, powerPreference: "high-performance" });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); 
    renderer.toneMapping = THREE.ACESFilmicToneMapping; 
    renderer.toneMappingExposure = 0.9;
    container.appendChild(renderer.domElement);

    // --- Post-processing (Bloom) ---
    const renderScene = new THREE.RenderPass(scene, camera);
    const bloomPass = new THREE.UnrealBloomPass(
        new THREE.Vector2(window.innerWidth, window.innerHeight),
        1.2, 0.4, 0.1  
    );

    const composer = new THREE.EffectComposer(renderer);
    composer.addPass(renderScene);
    composer.addPass(bloomPass);

    // --- ç´‹ç†ç”Ÿæˆ ---
    function getTexture() {
        const canvas = document.createElement('canvas');
        canvas.width = 32;
        canvas.height = 32;
        const ctx = canvas.getContext('2d');
        const gradient = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
        gradient.addColorStop(0, 'rgba(255,255,255,1)');
        gradient.addColorStop(0.2, 'rgba(255,255,255,0.8)');
        gradient.addColorStop(0.5, 'rgba(255,255,255,0.1)');
        gradient.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 32, 32);
        return new THREE.CanvasTexture(canvas);
    }
    const commonTexture = getTexture();

    // ==========================================
    // 1. åœŸæ˜Ÿç²’å­ç³»çµ±
    // ==========================================
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(config.particleCount * 3);
    const colors = new Float32Array(config.particleCount * 3);
    
    const planetRadius = 8;
    const ringInnerRadius = 10;
    const ringOuterRadius = 22;
    const planetParticleRatio = 0.45;

    const colPlanet = config.planetColor;
    const colRing = config.ringColor;

    for (let i = 0; i < config.particleCount; i++) {
        let x, y, z, r, g, b;
        
        if (i < config.particleCount * planetParticleRatio) {
            const dist = Math.pow(Math.random(), 0.5) * planetRadius; 
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            x = dist * Math.sin(phi) * Math.cos(theta);
            y = dist * Math.sin(phi) * Math.sin(theta);
            z = dist * Math.cos(phi);
            r = colPlanet.r + (Math.random() - 0.5) * 0.1;
            g = colPlanet.g + (Math.random() - 0.5) * 0.1;
            b = colPlanet.b + (Math.random() - 0.5) * 0.1;
        } else {
            const randVal = Math.random();
            const ringRad = Math.sqrt(randVal * (ringOuterRadius**2 - ringInnerRadius**2) + ringInnerRadius**2);
            const theta = Math.random() * Math.PI * 2;
            x = ringRad * Math.cos(theta);
            z = ringRad * Math.sin(theta);
            const thickness = 0.3 * (1 - (ringRad - ringInnerRadius)/(ringOuterRadius - ringInnerRadius));
            const wave = Math.sin(theta * 10) * 0.1;
            y = (Math.random() - 0.5) * thickness + wave * 0.2;
            const t = (ringRad - ringInnerRadius) / (ringOuterRadius - ringInnerRadius);
            r = colRing.r * (1-t) + t;
            g = colRing.g * (1-t) + t;
            b = colRing.b * (1-t) + t;
        }
        positions[i * 3] = x;
        positions[i * 3 + 1] = y;
        positions[i * 3 + 2] = z;
        colors[i * 3] = r;
        colors[i * 3 + 1] = g;
        colors[i * 3 + 2] = b;
    }

    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

    // ä½¿ç”¨ PointsMaterial
    const material = new THREE.PointsMaterial({
        size: 0.12, // ç²’å­å¤§å°
        map: commonTexture,
        vertexColors: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        transparent: true,
        opacity: 0.8
    });

    const planetSystem = new THREE.Points(geometry, material);
    scene.add(planetSystem);

    // ==========================================
    // 2. å¤šå±¤æ¬¡èƒŒæ™¯æ˜Ÿç©º
    // ==========================================
    const bgGroup = new THREE.Group();
    scene.add(bgGroup);

    const starCount = 5000;
    const starGeo = new THREE.BufferGeometry();
    const starPos = new Float32Array(starCount * 3);
    const starCol = new Float32Array(starCount * 3);
    for(let i=0; i<starCount; i++) {
        const r = 200 + Math.random() * 300;
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        starPos[i*3] = r * Math.sin(phi) * Math.cos(theta);
        starPos[i*3+1] = r * Math.sin(phi) * Math.sin(theta);
        starPos[i*3+2] = r * Math.cos(phi);
        const colorType = Math.random();
        let c = new THREE.Color();
        if(colorType > 0.8) c.setHex(0xffddaa); 
        else if(colorType > 0.6) c.setHex(0xaaddff);
        else c.setHex(0xffffff);
        starCol[i*3] = c.r; starCol[i*3+1] = c.g; starCol[i*3+2] = c.b;
    }
    starGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
    starGeo.setAttribute('color', new THREE.BufferAttribute(starCol, 3));
    const starMat = new THREE.PointsMaterial({
        size: 1.5, map: commonTexture, vertexColors: true, transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending
    });
    bgGroup.add(new THREE.Points(starGeo, starMat));

    // é æ™¯å¾®å¡µ
    const dustCount = 20000;
    const dustGeo = new THREE.BufferGeometry();
    const dustPos = new Float32Array(dustCount * 3);
    for(let i=0; i<dustCount*3; i++) {
        const r = 400 + Math.random() * 400;
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        dustPos[i] = r * Math.sin(phi) * Math.cos(theta);
        dustPos[i+1] = r * Math.sin(phi) * Math.sin(theta);
        dustPos[i+2] = r * Math.cos(phi);
    }
    dustGeo.setAttribute('position', new THREE.BufferAttribute(dustPos, 3));
    const dustMat = new THREE.PointsMaterial({
        color: 0x444466, size: 0.8, transparent: true, opacity: 0.4, sizeAttenuation: false
    });
    bgGroup.add(new THREE.Points(dustGeo, dustMat));


    // ==========================================
    // é¼ æ¨™ & è§¸å±æ§åˆ¶é‚è¼¯
    // ==========================================
    let isMouseDown = false;
    let clickX = 0;
    
    // è§¸æ‘¸è®Šé‡
    let touchStartDist = 0;
    let touchStartAngle = 0;
    let isPinching = false;

    // --- é¼ æ¨™äº‹ä»¶ ---
    window.addEventListener('mousemove', (e) => {
        if (handDetected) return;
        lastInteractionTime = clock.getElapsedTime();
        const x = e.clientX / window.innerWidth;
        const y = e.clientY / window.innerHeight;
        targetRotationY = (x - 0.5) * Math.PI * rotationSensitivity;
        targetRotationX = (y - 0.5) * Math.PI * rotationSensitivity;
        if (isMouseDown) {
            const deltaX = (e.clientX - clickX) / window.innerWidth;
            targetRotationZ += deltaX * 0.1;
        }
    });
    window.addEventListener('mousedown', (e) => { if(handDetected) return; isMouseDown = true; clickX = e.clientX; lastInteractionTime = clock.getElapsedTime(); });
    window.addEventListener('mouseup', () => { isMouseDown = false; });
    window.addEventListener('wheel', (e) => {
        if (handDetected) return;
        lastInteractionTime = clock.getElapsedTime();
        targetScale -= e.deltaY * 0.002;
        if(targetScale < 1.0) targetScale = 1.0;
        if(targetScale > 5.0) targetScale = 5.0;
        updateZoomUI(targetScale);
    });

    // --- è§¸å±äº‹ä»¶ (Mobile Touch) ---
    container.addEventListener('touchstart', (e) => {
        if (handDetected) return;
        lastInteractionTime = clock.getElapsedTime();
        
        if (e.touches.length === 2) {
            isPinching = true;
            const dx = e.touches[0].clientX - e.touches[1].clientX;
            const dy = e.touches[0].clientY - e.touches[1].clientY;
            touchStartDist = Math.sqrt(dx*dx + dy*dy);
            touchStartAngle = Math.atan2(dy, dx);
        }
    }, {passive: false});

    container.addEventListener('touchmove', (e) => {
        if (handDetected) return;
        e.preventDefault(); 
        lastInteractionTime = clock.getElapsedTime();

        if (e.touches.length === 1) {
            const x = e.touches[0].clientX / window.innerWidth;
            const y = e.touches[0].clientY / window.innerHeight;
            targetRotationY = (x - 0.5) * Math.PI * rotationSensitivity;
            targetRotationX = (y - 0.5) * Math.PI * rotationSensitivity;
        } 
        else if (e.touches.length === 2 && isPinching) {
            const dx = e.touches[0].clientX - e.touches[1].clientX;
            const dy = e.touches[0].clientY - e.touches[1].clientY;
            
            const dist = Math.sqrt(dx*dx + dy*dy);
            const deltaDist = dist - touchStartDist;
            targetScale += deltaDist * 0.005;
            if(targetScale < 1.0) targetScale = 1.0;
            if(targetScale > 5.0) targetScale = 5.0;
            touchStartDist = dist; 

            const angle = Math.atan2(dy, dx);
            const deltaAngle = angle - touchStartAngle;
            targetRotationZ += deltaAngle;
            touchStartAngle = angle;
            
            updateZoomUI(targetScale);
        }
    }, {passive: false});

    container.addEventListener('touchend', () => {
        isPinching = false;
    });


    // ==========================================
    // UI æ§åˆ¶å‡½æ•¸
    // ==========================================
    function toggleOverlay() {
        const overlay = document.getElementById('overlay');
        overlay.classList.toggle('hidden');
    }

    function adjustSensitivity(val) {
        rotationSensitivity += val;
        if(rotationSensitivity < 0.5) rotationSensitivity = 0.5;
        if(rotationSensitivity > 10.0) rotationSensitivity = 10.0;
        document.getElementById('sens-val').innerText = rotationSensitivity.toFixed(1);
    }

    function toggleRayTracing() {
        isRayTracing = !isRayTracing;
        const btn = document.getElementById('rtx-btn');
        if (isRayTracing) {
            btn.classList.add('active');
            btn.innerText = "âœ¨ å…‰ç·šè¿½è¹¤å·²é–‹å•Ÿ (High-DPI)";
            renderer.setPixelRatio(window.devicePixelRatio); 
            bloomPass.strength = 1.8; 
            bloomPass.radius = 0.6;
            renderer.toneMappingExposure = 1.2;
            composer.setSize(window.innerWidth * window.devicePixelRatio, window.innerHeight * window.devicePixelRatio);
        } else {
            btn.classList.remove('active');
            btn.innerText = "âœ¨ é–‹å•Ÿå…‰ç·šè¿½è¹¤ (æ¨¡æ“¬)";
            renderer.setPixelRatio(isMobile ? 1 : 1); 
            bloomPass.strength = 1.2;
            bloomPass.radius = 0.4;
            renderer.toneMappingExposure = 0.9;
            composer.setSize(window.innerWidth, window.innerHeight);
        }
    }

    function updateZoomUI(scale) {
        const zoomEl = document.getElementById('zoom-value');
        zoomEl.innerText = scale.toFixed(1) + "x";
        const t = (scale - 1.0) / 4.0;
        const hue = 180 + t * 180;
        zoomEl.style.color = `hsl(${hue}, 100%, 70%)`;
    }

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        const pixelRatio = isRayTracing ? window.devicePixelRatio : (isMobile ? 1 : 1);
        composer.setSize(window.innerWidth * pixelRatio, window.innerHeight * pixelRatio);
    });

    // ==========================================
    // æ¸²æŸ“å¾ªç’°
    // ==========================================
    const clock = new THREE.Clock();

    function animate() {
        requestAnimationFrame(animate);
        const time = clock.getElapsedTime();

        // å¹³æ»‘æ’å€¼
        planetSystem.rotation.x = THREE.MathUtils.lerp(planetSystem.rotation.x, targetRotationX, 0.08);
        planetSystem.rotation.y = THREE.MathUtils.lerp(planetSystem.rotation.y, targetRotationY, 0.08);
        planetSystem.rotation.z = THREE.MathUtils.lerp(planetSystem.rotation.z, targetRotationZ, 0.08);
        currentScale = THREE.MathUtils.lerp(currentScale, targetScale, 0.1);
        planetSystem.scale.set(currentScale, currentScale, currentScale);

        // å¾…æ©Ÿè‡ªå‹•å¾©ä½
        const timeSinceInteraction = time - lastInteractionTime;
        const isIdle = !handDetected && timeSinceInteraction > 2.0;

        if (isIdle) {
            targetRotationY += 0.0005; 
            bgGroup.rotation.y -= 0.0001;
            targetScale = 1.0; 
            updateZoomUI(currentScale); 
        }

        composer.render();
    }
    animate();

    // ==========================================
    // MediaPipe é‚è¼¯
    // ==========================================
    const videoElement = document.getElementById('input_video');
    const handStatus = document.getElementById('hand-status');
    const loadingScreen = document.getElementById('loading');

    function onResults(results) {
        if (loadingScreen.style.display !== 'none') loadingScreen.style.display = 'none';

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            if (!handDetected) {
                handDetected = true;
                lastInteractionTime = clock.getElapsedTime();
                handStatus.innerText = "â— å·²é€£æ¥ (æ‰‹å‹¢)";
                handStatus.style.color = "#00ff00";
                handStatus.style.textShadow = "0 0 10px #00ff00";
            }
            processHandInteraction(results.multiHandLandmarks[0]);
        } else {
            if (handDetected) {
                handDetected = false;
                handStatus.innerText = idleText;
                handStatus.style.color = "#888";
                handStatus.style.textShadow = "none";
            }
        }
    }

    function processHandInteraction(landmarks) {
        lastInteractionTime = clock.getElapsedTime();
        const wrist = landmarks[0];
        const middleMCP = landmarks[9];
        
        const handX = middleMCP.x;
        const handY = middleMCP.y;
        targetRotationY = (handX - 0.5) * Math.PI * rotationSensitivity;
        targetRotationX = (handY - 0.5) * Math.PI * rotationSensitivity;

        const dx = middleMCP.x - wrist.x;
        const dy = middleMCP.y - wrist.y;
        targetRotationZ = Math.atan2(dx, -dy);

        const thumbTip = landmarks[4];
        const indexTip = landmarks[8];
        const pinchDist = Math.hypot(thumbTip.x - indexTip.x, thumbTip.y - indexTip.y);
        
        let scale = 1.0 + (pinchDist - 0.05) * 8.0; 
        if (scale < 1.0) scale = 1.0;
        if (scale > 5.0) scale = 5.0;
        targetScale = scale;
        updateZoomUI(targetScale);
    }

    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5});
    hands.onResults(onResults);

    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => await hands.send({image: videoElement}),
        width: 640, height: 480
    });
    cameraUtils.start();

</script>
</body>
</html>
